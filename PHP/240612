2024/06/12の積み上げ

ログアウトの処理に関して、間違っていたことは次のようになる。

- ユーザーコントローラーのupdateアクションに記述忘れがあり、テストに通らなかった
    - 具体的には、$*user*->fill($*data*);を忘れていた
        - このコードはどういった役割を果たしているのだろうか？

公式ドキュメントをみて、Loginコントローラーのdestroyメソッドの中身は合っていた！ナイスおれ

今日、理解すること

1、下記、コードを他人に解説できるレベルで理解しよう

- DELETEリクエストで、/loginにアクセスすると、loginコントローラーのdestroyアクションを実行される
    - →name();の必要性ってわかる？
        - →name();は名前付きルートと呼ばれる
        - コントローラー、ビューでroute('login.destroy')と記載でき、保守性が高い
        - URL生成が容易になる。route('login.destroy')と記述できる
        - リダイレクトが容易になる。return redirect()->route('login.destroy')と記述できる

```php
Route::controller(LoginController::class)->group(function () {
    Route::get('login', 'create')->name('login.create');
    Route::post('login', 'store')->name('login.store');
    Route::delete('login', 'destroy')->name('login.destroy');
});
```

2、あと、なぜ下のコードにて、ログアウト処理はformを使っていて、ログインは不要なのか理解する

- ログアウト処理はDELETEメソッドを送信しているから
    - HTMLの制約上、DELETEリクエストを送信できないため、Laravelのメソッドスプーフィングを利用してフォームで送信する必要があります
    - フォーム内の隠しフィールドでHTTPメソッドを指定して送信している

```php
            @if(Auth::check())
                <!-- ログアウトフォーム -->
                <form id="logout-form"  action="{{ route('login.destroy') }}" method="POST">
                    @csrf
                    @method('DELETE')
                    <a class="nav-link" href="#" onclick="document.getElementById('logout-form').submit();">
                        ログアウト
                    </a>
                </form>
            @else
                <a class="nav-link" href="{{ route('login.create') }}">ログイン</a>
            @endif
```

3、あと、問題の切り分けもできるようになりたい

- ルーティング、コントローラー、ビューどこに問題があるのか
    - クロームのネットワークタブからHTTPリクエストを見るなど
    

4、usersコントローラーのupdateアクション内の$*user*->fill($*data*);を理解する

- リクエストから受け取ったデータをモデルの属性に一括で設定するためのメソッド
- `$request->all()`メソッドを使用して、HTTPリクエストから送信されたすべての入力データを取得できます。

最初に実装したいことを日本語にするのは大事。
やりたいことが明確になってないだけで、発想ができたらあとはこなすだけ

ログイン機能を日本語で詳細に分解する
「ログインする」と一口に言っても、具体的に何をどうすればいいのか想像しづらいかもしれません。
まずは、ログインとログアウトのプロセスを詳しく書き出してみましょう。

ログイン処理

1. 未ログインの状態で、ヘッダーにログインリンクが表示されます。
2. ユーザーは GET /login にアクセスしてログイン情報を入力します。
3. 入力されたログイン情報は POST /login に送信され、ログインの成否が決まります。
4. ログインに成功すると、ユーザーはログイン状態になります。
ログイン後の挙動

1. ページをリロードしても、ログイン状態は維持されます。
2. ヘッダーにはログインしているユーザーの名前が表示されます。
ログアウト処理

1. ログイン状態の時、ヘッダーにはログアウトリンクが表示されます。
2. ユーザーが /logout にアクセスすると、ログアウトされます。
ログイン機能をコントローラやビューの観点から考える
上記のプロセスをルーティング、コントローラ、ビューの処理に置き換えてみましょう。
（以下に各ステップに対応するリスト形式で説明します）

ログイン処理

※ 未ログインユーザー向け
1. src/resources/views/layouts/app.blade.php にログインページへのリンクを追加します。
1.5 `/login` のルーティングを設定します。
2. `GET /login` に対するコントローラとビューの設定を行います。
3. `POST /login` に対するコントローラの設定を行います。
4. ログイン成功時はユーザー一覧ページにリダイレクトし、失敗時はビューを再表示します。
ログイン後の挙動

※ ログインユーザー向け
1. ログイン情報はセッションに保存され、メソッドを呼び出してログインユーザーの情報を取得できるようにします。
2. src/resources/views/layouts/app.blade.phpにログインユーザーの名前を表示する設定を追加します。
ログアウト処理

※ ログインユーザー向け
1. `src/resources/views/layouts/app.blade.php` にログアウトリンクを追加します。
2. `DELETE /logout` のルーティングとコントローラの設定を行います。

